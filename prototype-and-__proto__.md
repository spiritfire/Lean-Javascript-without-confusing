# 原型与原型链

**原型？类型吧？是不是写错了，原型是什么毛玩意儿？**

难道你说的不是类型么，CLASS么，类再生成实例么？打错字了吧，怎么是原型？

我说的没错，就是原型，不是类型。在Javascript中，不久以前，没有“类”这个虚拟的概念。所有的对象都是“实例”，非常类似于现实世界中的样子。到这你可能有点confusing，请往下看。

```
但是：自从有了ES6之后，Javascript就也有了类class的概念了，
稍后再说这个。因为虽然有的类这个概念和保留字，但是实际上，他
TMD底层还是用原来的“原型”方式去实现的。
```

##     先说两件事：在JS的世界中，原则1：除基本数据类型外，万物皆实例，原则2：构成万物的基本物体有两种，空的function\(\)和空的object，其余物体都是构造在这两种物体之上。

OK到这里，举个生活中的例子：（前方高能，例子很长，请准备好4倍耐心）

1. 你想要做一道宫保鸡丁，所以你真真切切的写了一个”菜谱”：里面包含了菜和调料的名称，用量和制作方法.  （注意是真写了一个，不是脑子里虚构了一个，JS世界里不虚构，都是来真的）。

```text
function GongBaoJiDing()
{
    this.菜名 = "GBJD";
    this.主料 = "鸡肉";
    this.蔬菜 = "红萝卜";
    this.制作方法 = function() {return "ok";}
}
```

 既然要真写， 这里就涉及到一个问题，你这个_**菜谱写在哪**_？纸上？电脑里？ 假设是纸上，OK，你拿来了**一张白纸，这张白纸就是空function\(\)**，写下了上述**代码**。

 2. 现在有了菜谱了，那么你要真的做成这道菜了，如下代码：

```text
var GBJD_试做 = new GongBaoJiDing();
```

 要实实在在的做它，**照着那个“菜谱”，拿来一些空Object**, 来做成 `GBJD_试做` 这道菜。

看到这里估计还是很晕，我们来总结一下：

| 我们起的土名字： | 制作方法function GongBaoJiDing\(\) | 菜GBJD\_试做 |
| :--- | :--- | :--- |
| 正规名称： | 构造函数 | 实例 |
| 本身是什么： | 写在白纸\(空function\(\)\)上的方法 | _1.是一个有主料有蔬菜的菜   2. 是基于菜谱的指示，拿空物体按菜谱制成的。_ |
| 构造能力： | 有prototype（翻译：制造样品）能力 | 无prototype（翻译：制造样品）能力 |

有人问：菜谱什么时候告诉你拿空object来做了？你吹牛逼哦，请看下面，别急。

我们在chrome控制台敲一下看看：

![](.gitbook/assets/image%20%281%29.png)

_上图就看到了function GongBaoJiDing\(\)的内部构成，它有一个制造属性叫prototype，其中有一份制造方法就是它本身，其中还有一个\_\_proto\_\_是Object表明制造的时候要拿空物体来造。_

_function GongBaoJiDing\(\)还有个\_\_proto\_\_属性是一个空函数表明它是从何而来，说明这个菜谱本身，是写在一个空函数上面的，菜谱本身的原材料是一个空函数。_

_那我们在chrome控制台敲一下`GBJD_试做` 看一下喽：_

![](.gitbook/assets/image%20%287%29.png)

大家看到没，这玩意儿是可追溯的喔，有质量保证的喔，它不仅是有主料，有蔬菜，有制作方法的一道菜，而且它还有个\_\_proto\_\_属性，表明它是从何而来。我们可以很清楚的看到它是按照constructor里的构造函数，由空物体造出来的。

综上： prototype是有制造能力的function才具备的属性，它里面放的是制作方法，和基于什么东西制作。

             而\_\_proto\_\_表明了这个物体本身从何而来，也就是它的制造工艺，特殊要求，以及基于什么制造的。

你要是愿意，你可以把prototype这个制造样品的能力扩充一下，比如你可以说你要添加一个要求：“火力中火慢烧” （老板要打屎你喔）。

```text
GongBaoJiDing.prototype.火力 = "中火慢烧"；
```

![](.gitbook/assets/image%20%282%29.png)

看到了没？你可以加额外的制造要求的喔，是不是很神奇。

最神奇的是这个时候已经造出来的那盘菜，\_\_proto\_\_也是中火慢烧的喽，明明我们是先做出来才加的要求嘛。。。

![](.gitbook/assets/image%20%286%29.png)

没有办法喔，因为旧菜谱不会保留的喔，只会保留最新的，已经造出来的不管喔，因为你这是在追溯我现在的制造工艺喔, 追溯的可不是之前你是怎么做出来的喔。

综上： 如果我们是用一个function去定义制作方法，再用一个new 关键字去创建一个物体。

那么， function本身是用空函数造出来的，其体现于\_\_proto\_\_属性中。function中的prototype属性默认存储了制造方法（它本身）以及原材料（空物体），你也可以自己添加额外的要求（内容）到prototype里去。

然后new的时候，new出来的物体就有普通的属性，以及其\_\_proto\_\_属性中完整的保存着它的制造方法（构造函数），原材料（空物体），以及额外要求（通过prototype属性添加进去的）



## 真TMD复杂！！！！！！！！！！！！！！！！但是还没完。。。。。。。。。。。。。。。。

为啥没完？因为还有两种构造物体的方法：

其一： 用别的物体改一下改成新物体（就好比国产汽车拿别人底盘拉个皮就是新车了）。这种情况下程序代码就是Object.create\(进口车）。

其二： 直接声明一个物体不香么？比如 var 物体={呐喊：”直接声明出来不香么“}

好吧，我们来试下：



首先直接简单的声明一个进口车，可以看到它是直接基于一个空物体构造出来的，品牌是丰田的进口车。点开\_\_proto\_\_以后可以看到空物体的构造函数，构造出空物体后加一个品牌属性，就造就了我们的进口车。

![](.gitbook/assets/image%20%288%29.png)

接下来用Object.create\(进口车\)去搞一个衍生出来的国产车，也就是别的语言中所谓的“继承”。

![](.gitbook/assets/image%20%283%29.png)

可以十分清楚的看到它本质上是个丰田进口车。你可以随便加其他属性，但其实它\_\_proto\_\_里就是个丰田进口车，他一定有`品牌：丰田` 这个属性，它首先是一台真正的丰田进口车，然后才是国产车，你可以加国产属性，覆盖掉丰田品牌：

![](.gitbook/assets/image.png)

可以看到虽然覆盖了，但它还是一台真正的丰田，\_\_proto\_\_里的东西一直存在。

\_\_proto\_\_清楚的表明了它的来源  它是什么，从何而来，某物继承来？构造函数制造而来？还是直接声明？

而prorotype只存在于构造函数中，其完整了描述了某物的制造方法，原材料，以及特殊要求。

好像说到这里够清楚了。那么原型链是什么，我们再衍生一个宫保鸡丁罐头，请看下图：

![](.gitbook/assets/image%20%285%29.png)

一个宫爆鸡丁罐头，首先它是一个物体： 宫爆鸡丁罐头（A层），它骨子里含有另一个物体：宫爆鸡丁（层B），而物体宫爆鸡丁的\_\_proto\_\_又是一份完整的制作工艺和制作方法function GongBaoJiDing\(\)。

这样，你有了一个宫爆鸡丁罐头（层A），你就同时拥有了其\_\_proto\_\_（层B），那个宫爆鸡丁菜一份，也同时拥有了\_\_proto\_\_的\_\_proto\_\_\(层C）.所有A B C层的属性，对宫爆鸡丁罐头都是可见的。

这就叫原型链。这就是javascript的 ”对象和继承概念”

